# -*- coding: utf-8 -*-
"""
Created on Sun May  2 17:19:33 2021
@author: GVF, API, IHA, LDI

This module includes the functions to obtain the derivative of the velocity potential in the x-direction for a BVP result (either diffraction, (∂ϕ_7)/∂x, or radiation,  (∂ϕ_j^0)/∂x)

This function is generated by Maritime Technology Division (MTD) of Ghent University, Belgium. For more information regarding the implementation of forward speed please refer to:
    
L. Donatini, I. Herdayanditya, G. Verao Fernandez, A. B. K. Pribadi, E. Lataire, 
and G. Delefortrie, “Implementation of forward speed effects on an open source seakeeping 
solver,” in 6th MASHCON : international conference on ship manoeuvring in shallow and confined 
water with special focus on port manoeuvres, Glasgow, UK, 2022, pp. 20–33.
http://hdl.handle.net/1854/LU-8756868

        
"""
import numpy as np
import logging
import capytaine as cpt

def compute_dphidx(problems,results):
    """
    Computes the velocity vector field for all problems (NDoF Radiation + 1 Diffraction)*omega_range

    Parameters
    ----------
    results: list of LinearPotentialFlowResult
             The results that will be read to calculate the velocity vector field.     
             LinearPotentialFlowResult = the return of Nemoh's solver
    Returns in the class
    -------
    phi    = velocity potential
    dphidx = velocity in the x-direction
    """
    print('Computing Flow Velocity')
    
    ndof   = len(problems[0].influenced_dofs)
    npanel = results[0].problem.body.mesh.nb_faces
    dphidx = np.zeros((len(problems),npanel),dtype=complex)
        
    for ii in range(len(results)):
        if ii % (ndof+1)==0: # if module is zero then we calculate for a new frequency
            print('omega = '+str(round(problems[ii].omega,3))+' rad/s')
            #TODO: Confirm ajie if the results are in opposite dirrection
            dphidx[ii:ii+ndof+1,:] = -compute_vel_vector(ndof,results[ii:ii+ndof+1],results[ii].wavenumber_e)[:,:,0] 
        results[ii].dphidx = dphidx[ii]
        
    return results


def compute_phi_U_dphidx_U(results):
    """
    Computes the steady component of the velocity vector field for all problems (NDoF Radiation + 1 Diffraction)*omega_range

    Parameters
    ----------
    results: list of LinearPotentialFlowResult
             The results that will be read to calculate the velocity vector field.     
             LinearPotentialFlowResult = the return of Nemoh's solver
    Returns in the class
    -------
    phi_U    = steady component of the velocity potential
    dphidx_U = steady component of the velocity in the x-direction
    """
       
    dof  = results[0].influenced_dofs.keys()
    ndof = len(dof)
    dof  = np.array(dof)
    if 'Pitch' in dof or 'Yaw' in dof: 
        if 'Pitch' in dof and 'Heave' in dof: 
            if 'Heave' not in dof: 
                raise ValueError('Pitch cannot be solved because of no avalaibility in Heave results')
            else:
                #TODO: should be according to results order!!!!
                heave_loc = np.where(dof == 'Heave')[0]
                pitch_loc = np.where(dof == 'Pitch')[0]

        if 'Yaw' in dof:
            if 'Sway' not in dof:
                raise ValueError('Yaw cannot be solved because of no avalaibility in Sway results')
            else: 
                sway_loc = np.where(dof == 'Sway')[0]
                yaw_loc = np.where(dof == 'Yaw')[0]
            
    #To assign heave and yaw for third component solution
    for ii in range(len(results)):
        #update the dphidx_U for pitch and yaw 
        results[ii].potential_U = np.zeros(results[ii].dphidx.shape, dtype=complex)             
        results[ii].dphidx_U    = np.zeros(results[ii].dphidx.shape, dtype=complex)

    for ii in range(len(results)):
        if ii % (ndof+1)==0: #to track the radiation component so the index : +1
            if 'Pitch' in dof: 
                results[ii+1+pitch_loc].potential_U= results[ii+1+heave_loc].potential                    
                results[ii+1+pitch_loc].dphidx_U   = results[ii+1+heave_loc].dphidx
            if 'Yaw' in dof:
                results[ii+1+yaw_loc].potential_U  = -results[ii+1+sway_loc].potential
                results[ii+1+yaw_loc].dphidx_U     = -results[ii+1+sway_loc].dphidx
               
    return results

def compute_vel_vector(ndof,results,wavenumber_e):
    '''
    Computes the velocity vector field on each panel using 
    interaction matrices [K] for each "reconstructed panel" in x, y, z
    * see CAPYTAINE theory manual
    [K] = [1/2 + V]
    u = [K] * sigma
    
    Parameters
    ----------
    result: Radiation LinearPotentialFlowResult
            Diffraction LinearPotentialFlowResult
            LinearPotentialFlowResult = the return of Nemoh's solver
    freqdom:freqdom class
    wavenumber_e:  a float of wave number corresponds to the encounter frequency
    Returns 
    -------        
    Vel:    is an array that contains arrays of array with the following dimension: (7, number of panels, 3)
    
    7 is the total number of the source problems: 
        0: index for diffraction problem
        1: index for radiation problem in dof 1 (surge)
        2: index for radiation problem in dof 2 (sway)
        3: index for radiation problem in dof 3 (heave)
        4: index for radiation problem in dof 4 (roll)
        5: index for radiation problem in dof 5 (pitch)
        6: index for radiation problem in dof 6 (yaw)
        
    3 is the number of spatial dimension:
        0: index for velocity in x-axis
        1: index for velocity in y-axis
        2: index for velocity in z-axis
    
    e.g., vel[1, :, 0] gives a one-dimensional array containing the 
        velocity component in x-direction for the diffraction problem in dof 1 (surge)
    '''
    #import matplotlib.pyplot as plt
    #from mpl_toolkits.mplot3d.art3d import Poly3DCollection, Line3DCollection
    engine = cpt.BasicMatrixEngine()
    green_function = cpt.Delhommeau()
    

    #ax = plt.axes(projection='3d')
    water_depth = results[0].water_depth
    mesh        = results[0].body.mesh   
    sigma = np.zeros((ndof+1, len(mesh.faces_centers)), dtype=complex)   
    vel = np.zeros((ndof+1, len(mesh.faces_centers), 3),dtype=complex) # 7 problems, len of num of panels, 3 spatial dimensions   
    for jj in range(ndof+1):
        sigma[jj] = results[jj].sources
    for jj in range(len(mesh.faces_centers)):            
        new_mesh_x, old_mesh = generate_face_x(mesh, index =jj, y=3, z=3) # create a panel with a normal component facing x-axis
        new_mesh_y, old_mesh = generate_face_y(mesh, index =jj, x=3, z=3) # create a panel with a normal component facing y-axis
        new_mesh_z, old_mesh = generate_face_z(mesh, index =jj, x=3, y=3) # create a panel with a normal component facing z-axis
        # # now we need to compute [K] and [S] matrices for each panel in each direction
        Sdummy_x, Kdummy_x = engine.build_matrices(
        new_mesh_x, mesh,
        free_surface=0.0, sea_bottom=-water_depth,
        wavenumber=wavenumber_e,
        green_function=green_function,
        )
        Sdummy_y, Kdummy_y = engine.build_matrices(
        new_mesh_y, mesh,
        free_surface=0.0, sea_bottom=-water_depth,
        wavenumber=wavenumber_e,
        green_function=green_function,
        )
        Sdummy_z, Kdummy_z = engine.build_matrices(
        new_mesh_z, mesh,
        free_surface=0.0, sea_bottom=-water_depth,
        wavenumber=wavenumber_e,
        green_function=green_function,
        )
        K_mat = [Kdummy_x, Kdummy_y, Kdummy_z]    
        for ii in range(ndof+1):
            for kk in range(3):
                vel[ii, jj, kk] = K_mat[kk] @ sigma[ii]
    # Plot the newly created panel (new_mesh_x)
    #     v2 = new_mesh_x.vertices
    #     f2 = new_mesh_x.faces
    #     c1 = old_mesh.faces_centers
    #     v1 = old_mesh.vertices
    #     f1 = old_mesh.faces
    #     pc2 = Poly3DCollection(v2[f2], facecolors = 'blue',edgecolor="black")
    #     pc = Poly3DCollection(v1[f1], facecolors = 'red',edgecolor="black")
    #     ax.add_collection(pc2)
    #     ax.add_collection(pc)
    # ax.set_xlim(-50, 50)
    # ax.set_ylim(-20, 20)
    # ax.set_zlim(-20, 20)
    # ax.set_box_aspect(aspect = (3,2,1))
    # plt.legend()

    return vel

def generate_face_x(mesh, index, y, z):
    '''
    Parameters
    ----------
    mesh: mesh of the floating body
    index:index of a panel to which a flat panel facing x-axis will be generated
    y:length of the flat panel in the y-axis to be generated (in meter)
    z:length of the flat panel in the z-axis to be generated (in meter)
    Returns 
    ------- 
    '''
    mesh_centroid = mesh.faces_centers[index] 
    mesh_normal = mesh.faces_normals[index]
    displacement_magnitude = 0.001
    displacement = mesh_normal * displacement_magnitude    
    mesh_centroid = mesh_centroid + displacement
    mesh_face = mesh.faces[index]

    old_vertices = np.zeros((4, 3))

    
    for jj in range(4):
        old_vertices[jj] = mesh.vertices[mesh_face[jj]]

    new_vertices = np.zeros((4, 3))
    faces_displaced = [[0, 1, 2, 3]]
    for jj in range(4):
        if jj == 0:
            dy = y
            dz = z
        elif jj == 1:
            dy = y
            dz = -1*z
        elif jj == 2:
            dy = -1*y
            dz = -1*z
        elif jj == 3:
            dy = -1*y
            dz = z
        
        new_vertices[jj, 0] = mesh_centroid[0]
        new_vertices[jj, 1] = mesh_centroid[1] + dy
        new_vertices[jj, 2] = mesh_centroid[2] + dz

    displaced_mesh = cpt.meshes.meshes.Mesh(new_vertices, faces_displaced)
    old_mesh = cpt.meshes.meshes.Mesh(old_vertices, faces_displaced)

    return displaced_mesh, old_mesh

def generate_face_y(mesh, index, x, z):
    '''
    Parameters
    ----------
    mesh: mesh of the floating body
    index:index of a panel to which a flat panel facing x-axis will be generated
    x: length of the flat panel in the x-axis to be generated (in meter): 
    z: length of the flat panel in the z-axis to be generated (in meter): 
    Returns 
    ------- 
    '''
    mesh_centroid = mesh.faces_centers[index]
    mesh_normal = mesh.faces_normals[index]
    displacement_magnitude = 0.001
    displacement = mesh_normal * displacement_magnitude
    mesh_centroid = mesh_centroid + displacement
    mesh_face = mesh.faces[index]
    old_vertices = np.zeros((4, 3))

    for jj in range(4):
        old_vertices[jj] = mesh.vertices[mesh_face[jj]]

    new_vertices = np.zeros((4, 3))
    faces_displaced = [[0, 1, 2, 3]]
    for jj in range(4):
        if jj == 0:
            dx = x
            dz = z
        elif jj == 1:
            dx = x
            dz = -1*z
        elif jj == 2:
            dx = -1*x
            dz = -1*z
        elif jj == 3:
            dx = -1*x
            dz = z

        new_vertices[jj, 0] = mesh_centroid[0] + dx
        new_vertices[jj, 1] = mesh_centroid[1] 
        new_vertices[jj, 2] = mesh_centroid[2] + dz
        
    displaced_mesh = cpt.meshes.meshes.Mesh(new_vertices, faces_displaced)
    old_mesh = cpt.meshes.meshes.Mesh(old_vertices, faces_displaced)

    return displaced_mesh, old_mesh

def generate_face_z(mesh, index, x, y):
    '''
    Parameters
    ----------
    mesh: mesh of the floating body
    index:index of a panel to which a flat panel facing x-axis will be generated
    x: length of the flat panel in the x-axis to be generated (in meter): 
    y: length of the flat panel in the y-axis to be generated (in meter): 
    Returns 
    ------- 
    '''
    mesh_centroid = mesh.faces_centers[index]
    mesh_normal = mesh.faces_normals[index]
    displacement_magnitude = 0.001
    displacement = mesh_normal * displacement_magnitude
    mesh_centroid = mesh_centroid + displacement   
    mesh_face = mesh.faces[index]
    old_vertices = np.zeros((4, 3))
    
    for jj in range(4):
        old_vertices[jj] = mesh.vertices[mesh_face[jj]]

    new_vertices = np.zeros((4, 3))
    faces_displaced = [[0, 1, 2, 3]]
    for jj in range(4):
        if jj == 0:
            dx = x
            dy = y
        elif jj == 1:
            dx = x
            dy = -1*y
        elif jj == 2:
            dx = -1*x
            dy = -1*y
        elif jj == 3:
            dx = -1*x
            dy = y
        
        new_vertices[jj, 0] = mesh_centroid[0] + dx
        new_vertices[jj, 1] = mesh_centroid[1] + dy
        new_vertices[jj, 2] = mesh_centroid[2]
        
    displaced_mesh = cpt.meshes.meshes.Mesh(new_vertices, faces_displaced)
    old_mesh = cpt.meshes.meshes.Mesh(old_vertices, faces_displaced)

    return displaced_mesh, old_mesh